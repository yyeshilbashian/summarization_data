Ներկայումս լայն տարածում են ստացել ոչ տիպականացված սկրիպտային լեզուներով գրված ծրագրերը։
 Ծրագրավորման այդտեսակ լեզուներից լայն 
տարածում  ունի  JavaScript  ծրագրավորման  լեզուն։
  Համակարգիչների  և  ներդրված  համակարգերի  արդյունավետության  բարձրացման  հետ  մեկտեղ 
JavaScript լեզվի  գործածումը հնարավոր դարձավ ոչ միայն վեբ կայքերում օգտագործվող փոքր ծավալով սկրիպտային ծրագրերում, այլ նաև ծավալուն վեբ 
ծրագրերում։
  Ավելին, որոշ  օպերացիոն համակարգեր  JavaScript  լեզուն  օգտագործում են որպես հիմնական ծրագրավորման լեզու։
 Այդպիսի համակարգերի 
օրինակ են Tizen[1] և FirefoxOS օպերացիոն համակարգերը։
 Որպես հետևանք` 
առաջանում  է  սկրիպտային  ծրագրերի  արդյունավետության  բարձրացման 
պահանջարկ։
Այս  աշխատանքում  դիտարկվում  է  JavaScript  լեզվի  JavaScriptCore  (JSC) 
JIT  կոմպիլյատորը,    որը    վեբ  կայքերի  արտացոլման  համար  նախատեսված 
WebKit  գրադարանի մի մասն է։
  Աշխատանքի նպատակն է JavaScriptCore JIT 
կոմպիլյատորում  օպտիմալացումների  մշակումը  և  իրականացումը,  որոնք 
կհանգեցնեն ավելի որակյալ կոդի գեներացմանը, ինչն էլ իր հերթին կհանգեցնի 
JavaScript լեզվով գրված ծրագրերի արտադրողականության բարձրացմանը։
  JavaScriptCore կոմպիլյատորի կառուցվածքը[2] 
JavaScriptCore  կոմպիլյատորի  աշխատանքի  սկզբում  կատարվում  է 
լեկսիկական  և  սինտակսիկական  անալիզ։
  Սկզբնական  կոդի  հիման  վրա 
կառուցվում  է  աբստրակտ  սինտակս  ծառ,  որի  հիման  վրա  այնուհետև 
կառուցվում է միջանկյալ ներկայացումը (բայթկոդ)։
JavaScriptCore կոմպիլյատորի  աշխատանքը ներկայացված է նկար 1-ում։
                                                  Նկար 1 
Կախված կոդի կատարման ինտենսիվությունից՝ սկզբնական կոդը թարգմանվում է մեքենայական կոդի օպտիմալացման 4 փուլերով։
Առաջին փուլում կատարվում է ծրագրի ուղղակի ինտերպրետացում։
  Այս 
փուլի  ընթացքում  տվյալներ  են  հավաքվում  փոփոխականների  տիպերի  և 
օբյեկտների  դաշտերի  արժեքների  վերաբերյալ։
  Որպեսզի  ֆունկցիայի  թարգմանությունն անցնի երկրորդ փուլ (Baseline JIT), անհրաժեշտ է, որ ֆունկցիան 
հավաքի 100 «կատարման միավոր», ընդ որում ֆունկցիայի ամեն կանչն ավելացնում է 15 միավոր, իսկ ցիկլի ամեն քայլ՝ 1 միավոր։
Թարգմանության  երկրորդ  փուլում  կատարվում  է  ֆունկցիայի  դինամիկ 
կոմպիլյացիա մեքենայական կոդի։
 Ստացված մեքենայական կոդում ամեն գործողության  համար  ներառված  են  կատարման  բոլոր  հնարավոր  տարբերակները։
  Օրինակ՝  գումարման  գործողության  արգումենտները  կարող  են  լինել 
թվեր կամ տառեր։
 Երկրորդ դեպքում գործողությունը պետք է կատարվի ինչպես 
տողերի  կոնկոտենացիա։
  Այսպիսով՝  ստացված  կոդը  կարող  է  պարունակել 
բազմաթիվ ճյուղավորումներ բոլոր նմանատիպ դեպքերը մշակելու համար։
Տիպերի և օբյեկտների մասին տվյալները, որոնք հավաքվում են առաջին 
երկու փուլերում, անհրաժեշտ են թարգմանության երրորդ փուլում սպեկուլյատիվ թարգմանության կազմակերպման համար։
Թարգմանության  երրորդ  փուլը  (DFG  JIT)  կատարվում  է  այն  ֆունկցիաների  համար,  որոնք հավաքել  են  ավելի  քան 1000  «կատարման  միավոր»։
  Այս 
փուլում կատարվում են բազմատեսակ օպտիմալացումներ, որոնք հիմնված են 
տիպերի մասին տվյալների վրա։
 Բայթկոդ միջանկյալ ներկայացումից կառուցվում է տվյալների հոսքի գրաֆ (Data Flow Graph)[3], որում գործողությունները 
ներկայացված են SSA[3] տեսքով։
DFG  JIT  կոմպիլյատորը  տիպերի  մասին  ստացված  ինֆորմացիան  տարածում  է  տվյալների  գրաֆով  և  կոդում  ավելացնում  է  տիպերի  անհրաժեշտ 
ստուգումներ։
Եթե  տիպի  ստուգման  արդյունքը  բացասական  է,  ապա  կատարվում  է 
անցում դեպի կատարման երկրորդ փուլ (OSR exit), որտեղ մեքենայական կոդում ներառված են տիպերի մշակման բոլոր դեպքերը։
 Այսպիսով՝ Baseline JIT և 
DFG JIT փուլերում գեներացված մեքենայական կոդերը կարող են փոխարինել 
միմյանց։
  Երբ  ֆունկցիան  հավաքում  է  բավարար  «կատարման  միավոր»,  կատարվում է անցում դեպի DFG JIT (OSR entry), իսկ երբ տեղի է ունենում փոփոխականի  տիպի  դինամիկ  փոփոխություն,  կատարվում  է  հակառակ  անցում 
(OSR exit)։
 Թարգմանության չորրորդ փուլը կոչվում է LLVM JIT և կատարվում է 
այն ֆունկցիաների համար, որոնք հավաքել են ավելի քան 10000 «կատարման 
միավոր»։
  Այստեղ  միջանկյալ  կոդի  փոխարեն  հանդես  է  գալիս  LLVM[4]  կոմպիլյատորի  բիթկոդը,  և  կատարվում  են  ավելի մեծ  թվով    օպտիմալացումներ, 
այդ  թվում  ՝  LLVM  կոմպիլյատորում  իրականացված  օպտիմալացումների  մեծ 
մասը։
JavaScriptCore  դինամիկ  կոմպիլյատորի  ճարտարապետության  ուսումնասիրությունների արդյունքում պարզվեց, որ DFG JIT կոմպիլյատորում ֆիզիկական  ռեգիստրների  բաշխումը  կատարվում  է  լոկալ  եղանակով,  բազային 
բլոկների  սահմաններում,  ինչը  հանգեցնում  է  նրան,  որ  ամեն  բազային  բլոկի 
ելքում բոլոր լոկալ փոփոխականներն արտագրվում են հիշողության մեջ և հաջորդ  բազային  բլոկի  մուտքում  կրկին  բեռնվում  են  հիշողությունից։
  Հիշողությանն ուղղված ավելորդ դիմումներից ազատվելու համար մշակվել և իրականացվել է ռեգիստրների գլոբալ բաշխման ալգորիթմ JavaScriptCore JIT կոմպիլյատորում։
  Որպես հիմք  ընտրվել  է  գծային  սկանավորման  (Linear  scan)  ալգորիթմը[5]։
  Այս ալգորիթմն իրականացված է SSA միջանկյալ ներկայացման համար,  որը  նաև  հանդիսանում  է  DFG  JIT  կոմպիլյատորի  միջանկյալ  ներկայացումը։
 Ալգորիթմի իրականացման ընթացքում հաշվի են առնվել JavaScriptCore 
կոմպիլյատորի հետևյալ առանձնահատկությունները. 
1.  Փոփոխականների  տիպերը  որոշվում  են  դինամիկ,  և  տիպերի  մասին 
ինֆորմացիան պետք է հավաքել մինչև ռեգիստրների բաշխումը։
2.  32  բիթանոց  ճարտարապետությունների  համար  փոփոխականի  տիպը  և 
արժեքը պահվում են տարբեր ռեգիստրներում։
3.  Որոշ  հրամաններ  թարգմանելու  համար  անհրաժեշտ  են  ժամանակավոր 
ռեգիստրներ։
JavaScriptCore դինամիկ կոմպիլյատորում ռեգիստրների լոկալ բաշխումը 
կատարվում էր կոդի գեներացիայի ընթացքում։
 Այս փուլում հասանելի են հրամանները  թարգմանելու  համար  ռեգիստրների  անհրաժեշտ  քանակի  և  փոփոխականների տիպերի վերաբերյալ պահանջվող բոլոր տվյալները։
  Ռեգիստրների  գլոբալ  բաշխման  ալգորիթմն  իր  աշխատանքն  սկսում  է  մինչև  կոդի 
գեներացիայի  փուլը,  որտեղ  այդ  տվյալները  հասանելի  չեն։
    Խնդիրը  լուծելու 
համար կոմպիլյատորում ավելացվել է նոր փուլ, որն աշխատում է անմիջապես 
ռեգիստրների  բաշխման  փուլից  առաջ,  և  հավաքում  է  անհրաժեշտ  տվյալներ 
փոփոխականների տիպերի և ռեգիստրների պահանջվող քանակի վերաբերյալ։
Ռեգիստրների  գլոբալ  բաշխումն  իրականացնելուց  հետո  հնարավոր  դարձավ 
հեռացնել  բազային  բլոկների  մուտքերում  և  ելքերում  հիշողությանն  ուղղված 
ավելորդ դիմումները, բացառությամբ այն դեպքերի, երբ բազային բլոկը գտնվում 
է  ցիկլի  մարմնի  մեջ։
  Ծրագրի  կատարումը  կարող  է  անցնել  baseline  JIT 
կոմպիլյատորից դեպի DFG JIT կոմպիլյատոր ցիկլի առաջին հրամանի կատարման  ժամանակ  (OSR  Entry)[2]։
  Այդ  դեպքում  հարկավոր  է  բեռնել  բոլոր 
անհրաժեշտ  լոկալ  փոփոխականների  արժեքները  ֆիզիկական  ռեգիստրների 
մեջ։
  Խնդիրը  լուծելու  համար  միջանկյալ  ներկայացման  մեջ  ավելացվել  է  նոր 
բազային բլոկ, որտեղ տեղադրվել են հրամաններ լոկալ փոփոխականների արժեքները ֆիզիկական ռեգիստրների մեջ բեռնելու համար։
  Այնուհետև DFG JIT 
կոմպիլյատորի մուտքի հասցեն փոխվել է այնպես, որ այն մատնանշի նոր կառուցված բազային բլոկի մուտքի հասցեն, ինչպես պատկերված է նկար 2-ում։
Նկար 2 
Ծրագրում օգտագործված փոփոխականների քանակը կարող է գերազանցել  առկա  ֆիզիկական  ռեգիստրների  քանակը։
  Այդ  դեպքում  որոշ  փոփոխականներ հարկավոր է պահել հիշողության մեջ։
  Հիշողության դիմումները նվազագույնին  հասցնելու  համար  հարկավոր  է  հաճախ  օգտագործվող  փոփոխակաների  արժեքները  հնարավորության  դեպքում  պահել  ֆիզիկական  ռեգիստրներում։
  Այդ  նպատակով  ծրագրի  բոլոր  փոփոխականներին  համապատասխանեցվում է  «փոփոխականի  քաշ»  մեծությունը,  որը ուղիղ համեմատական է ծրագրի մեջ տվյալ փոփոխականի օգտագործման քանակին և այն ցիկլի 
խորությանը, որի մարմնում գտնվում է տվյալ փոփոխականը։
Այնուհետև ավելի փոքր քաշ ունեցող փոփոխականները համապատասխանաբար պահվում են հիշողության մեջ, իսկ մեծ քաշ ունեցողները՝ ֆիզիկական ռեգիստրներում։
JavaScriptCore  կոմպիլյատորի  ուսումնասիրության  արդյունքում  պարզվեց, որ գոյություն ունեն հրամաններ, որոնք իրականացված չեն օպտիմալացման երրորդ (DFG JIT) մակարդակում, ինչի պատճառով առաջանում են դեպքեր, 
երբ շատ անգամ կատարված ֆունկցիան, միևնույնն է, չի թարգմանվում DFG JIT 
կոմպիլյատորի միջոցով։
 Այդպիսի հրամանի օրինակ է փոփոխականների տիպերի  որոշման  typeof  հրամանը։
  Այս  հրամանը  պարունակող  ֆունկցիաները 
կատարվում էին  միայն  օպտիմալացման  առաջին  (LLINT)  և երկրորդ  մակարդակներում  (baseline  JIT)։
    Այդ  տեսակ  հրամանի  մեկ  այլ  օրինակ  են  ցիկլերը, 
որոնք նախատեսված են օբյեկտի անդամ տվյալների թվարկման համար (for-in 
ցիկլեր)։
 DFG JIT մակարդակում իրականացվել է թվարկված երկու հրամանների 
թարգմանությունը, ինչը ավելացրել է օպտիմալացման երրորդ մակարդակում 
թարգմանվող ֆունկցիաների քանակը։
Ուսումնասիրությունները ցույց տվեցին նաև, որ որոշ բարդ հրամանների 
թարգմանութունը իրականցված է C – լեզվի ֆունկցիաների կանչերի միջոցով, 
ինչը պահանջում է բավական շատ ժամանակ ստեկի, ֆունկցիայի արգումենտների պատրաստման և ֆունկցիայի կանչի համար։
 Գեներացվող մեքենայական 
կոդի որակի բարելավման նպատակով որոշ այդպիսի հրամանների մեքենայական  կոդում  ֆունկցիայի  կանչը  փոխարինվել  է  հրամանի  ուղղակի  ասեմբլերային կոդով։
Վերոնշյալ օպտիմալացումը կատարվել է JavaScript լեզվի հետևյալ ֆունկցիաների համար։
 Math.power, Math.floօr, Math.power, String.fromCharCode։
Տվյալ աշխատանքի սահմաններում JavaScriptCore JIT կոմպիլյատորի համար մշակվել և իրականացվել են մեքենայական կոդի օպտիմալացման մի քանի 
եղանակներ, ինչպես նաև իրականացվել է ռեգիստրների գլոբալ բաշխման ալգորիթմը։
Այս ամենը հանգեցրել է գեներացված կոդի որակի զգալի բարելավմանը։
 Նոր հրամանների թարգմանության իրականացումը SunSpider [6] թեսթային 
հավաքածուի որոշ թեսթերի արտադրողականությունը ավելացրել է 15% -ով։
Ռեգիստրների գլոբալ բաշխումը որոշ թեսթերի արտադրողականությունը 
բարելավել է ավելի քան 20% -ով։

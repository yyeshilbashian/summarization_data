ԿՈԴԻ ԿԼՈՆՆԵՐԻ ՈՐՈՆՈՒՄ «JAVA» ԾՐԱԳՐԱՎՈՐՄԱՆ  
ԼԵԶՎԻ ՀԱՄԱՐ՝ ՀԻՄՆՎԱԾ ԾՐԱԳՐԻ ՍԵՄԱՆՏԻԿ 
ՀԵՏԱԶՈՏՈՒԹՅԱՆ ՎՐԱ 
Ներածություն։
  Ծրագրավորողը  կարող  է  օգտագործել  ծրագրի  միևնույն 
մասը մի  քանի անգամ՝ որոշակիորեն այն  փոփոխելով։
 Կոդի պատճենումն ու 
նրա օգտագործումը կարող է հանգեցնել սեմանտիկ սխալների։
 Օրինակ, ծրագրավորողը  կարող  է  մոռանալ  կոդի  պատճենված  մասի  որոշ  փոփոխականների  վերանվանումը,  որը  կհանգեցնի  սխալի։
  Կոդի  հատվածի  կրկնակի  օգտագործումը  հաճախ  է  հանդիպում  մեծ  ծրագրային  համակարգերում։
  Այն 
ծրագիրը, որտեղ կլոնները շատ են, հավանաբար, կպարունակի շատ սխալներ 
և  կունենա  ցածր  որակ։
  Ըստ  տարբեր  հետազոտությունների  [1,  2]  ծրագրի 
20%-ը  կարող  է  լինել  կլոն։
  Կոդի  կլոնների  որոնման  գործիքներն  ունեն  բազմաթիվ կիրառություններ․ 
●  Կոդի որակի անալիզ  
●  Հեղինակային իրավունքների խախտումների հայտնաբերում 
●  Վիրուսների հայտնաբերում 
●  Սխալների հայտնաբերում 
Հոդվածում  կներկայացվի,  թե  ինչպես  է  իրականացվում  կոդի  կլոնների 
որոնումը Java ծրագրավորման լեզվի համար։
 Առաջին մասում ներկայացվում է 
ծրագրի  կախվածությունների  գրաֆի  (PDG)  ստացումը։
  Երկրորդ  մասում 
անալիզ  են  արվում  PDG-ները՝  կոդի  կլոններ  որոնելու  համար։
  Կիրառվում  է 
նոր  ալգորիթմ՝  PDG-ից  ծառ  ստանալու  և  երկու  ծառերի  մաքսիմալ  իզոմորֆ 
ենթածառեր  գտնելու  համար։
  Ալգորիթմը  նախնական  կոդի  միլիոնավոր  տողերի անալիզի հնարավորություն է տալիս։
Կոդի  կլոնի տիպեր։
 Գոյություն ունեն 3 հիմնական տիպի կոդի կլոններ։
Առաջին  տիպի  կլոնները  դրանք  կոդի  այն  հատվածներն  են,  որոնք  կարող  են 
տարբերվել միայն բացատներով և մեկնաբանություններով (T1) ։
 Երկրորդ տիպի կլոնները դրանք կոդի այն հատվածներն են, որոնք կարող են տարբերվել 
բացատներով,  մեկնաբանություններով,  փոփոխականների  անուններով, 
նրանց  տիպերով  և  արժեքներով  (T2)։
  Երրորդ  տիպի  կլոնները  դրանք  կոդի 
այն  հատվածներն  են,  որոնք  կարող  են  տարբերվել  բացատներով,  մեկնաբանություններով,  փոփոխականների  անուններով,  նրանց  տիպերով  և  արժեքներով, ինչպես նաև կարող են ավելանալ կամ ջնջվել կոդի որոշ տողեր (T3) [3] 
(Նկ․ 1)։
4։
 void sumProd(int 
5։
 ﬂoat sum = 0.0; 
6։
 ﬂoat prod = 1.0; 
7։
 for (int i = 1; 
8։
 sum = sum + i; 
9։
 prod = prod * i; 
10։
 foo(sum, prod); 
11։
 } 
12։
 } 
Գծ․ 1․ Երեք տիպի կլոնների օրինակներ 
Կոդի  կլոնների  որոնման  մոտեցումները։
  Կոդի  կլոնների  որոնման  համար կիրառվում են տարբեր մոտեցումներ։
 Ամեն մոտեցում ունի իր առավելությունները  և  թերությունները  կոնկրետ  տիպի  կլոններ  գտնելու  համար։
  Բոլոր 
մոտեցումների  դեպքում  գլխավոր  պահանջը  գտնված  կլոնների  կոռեկտությունն է։
 Գոյություն ունի կոդի կլոնների որոնման 5 հիմնական մոտեցում․ 
 Տեքստային 
 Լեքսիկական 
 Սինտաքսային  
 Մետրիկաների վրա հիմնված 
 Սեմանտիկական  
1.  Տեքստային  մոտեցում։
  Ալգորիթմները,  որոնք  հիմնված  են  այս 
մոտեցման  վրա,  հիմնականում  հեշավորում  են  մի  քանի  տողեր,  այնուհետև 
համեմատում  են  հեշերը  [4]։
  Եթե  հեշերը  համընկնում  են,  ապա  ալգորիթմը 
դրանք համարում է կլոններ։
 Որոշ ալգորիթմներ կարողանում են գտնել նման 
ֆայլեր։
  Այդ  դեպքում  վերցվում  է  որոշակի  տողերի  հաջորդականություն  և 
հաշվվում  է  ստուգիչ  գումար  նրանց  համար։
  Այնուհետև  ֆայլերի  փոխարեն 
համեմատվում  են  այդ  գումարները։
  Համընկնման  դեպքում  ֆայլերը  համարվում  են  կլոններ։
  Այս  մոտեցման  թերությունն  այն  է,  որ  գտնում  է  միայն  (T1) 
տիպի  կլոններ։
  Այսպիսի  ալգորիթմների  բարդությունը  քառակուսային  է 
ստացված հեշերի քանակի նկատմամբ։
2. Լեքսիկական մոտեցում։
 Այս մոտեցման դեպքում լեքսիկական անալիզատորի  միջոցով  կոդը  թարգմանվում  է  թոքենների  հաջորդականության,  ինչից հետո ալգորիթմը որոնում է համընկնող թոքենների ենթահաջորդականություններ  [5]։
  Այս  մոտեցմամբ  հնարավոր  է  գտնել  (T1)  և  (T2)  տիպի  կլոններ։
Վատագույն դեպքում այսպիսի ալգորիթմների բարդությունը քառակուսային է 
թոքենների  թվից  կախված,  սակայն  գործնականում  նրանք  աշխատում  են 
բավական արագ։
3.  Սինտաքսային  մոտեցում։
  Այս  մոտեցումը  հիմնված  է  AST  (abstract 
syntax  tree)  ծառերի  վրա։
  Կլոններ  համարվում  են  AST  ծառի  իզոմորֆ  ենթածառերը։
  Իզոմորֆ  ենթածառերի  որոնման  համար  կիրառվում  են  տարբեր 
ալգորիթմներ․ 
 երկու ծառերի մեջ փնտրվում է ամենամեծ ընդհանուր ենթածառը [6]։
 երկու ծառերի համար կառուցվում են վերջածանցային ծառեր, որոնց 
վրա որոնվում են կլոններ [7]։
 երկու  ծառերի  ենթածառերի  համար  կառուցվում  են  բնութագրիչ 
վեկտորներ, որոնք և համեմատվում են [8]։
Այսպիսի  ալգորիթմների  բարդությունը  տատանվում  է  գծայինից  մինչև 
քառակուսայինի  AST  ծառի  գագաթների  թվի  նկատմամբ։
  Այն  կախված  է 
մինիմալ  դիտարկվող  ենթածառերի  չափերից։
  Այս  մոտեցման  վրա  հիմնված 
մեթոդները գտնում են բոլոր տիպի կլոններ։
4.  Մետրիկայի  վրա  հիմնված  մոտեցում։
  Կոդի  կտորների  համար  հաշվվում  են  տարբեր մետրիկաներ, իսկ հետո համեմատում են  ստացված մետրիկաները։
  Հիմնականում  հաշվում  են  AST  ծառերի,  ծրագրի  կախվածությունների  գրաֆի  կամ  տվյալների  հոսքի  գրաֆի  համար  մետրիկաներ։
  Այսինքն, 
նախապես  նախնական  կոդից  ստացվում  է  AST  ծառ,  ծրագրի  կախվածությունների  գրաֆ  կամ  տվյալների  հոսքի  գրաֆ,  նրանց  համար  սահմանվում  է 
կոդի  միավոր,  ապա  յուրաքանչյուր  կոդի  միավորի  համար  հաշվվում  են  մետրիկաները։
  Մետրիկաները  հաշվարկվելուց  հետո  զույգ  առ  զույգ  համեմատվում  են  [9]։
  Որպես  կանոն  այս  մոտեցման  մեթոդներն  աշխատում  են  ավելի 
արագ,  քան  AST  ծառերի,  ծրագրի  կախվածությունների  գրաֆի  (PDG)  կամ 
տվյալների  հոսքի  գրաֆի  վրա հիմնված ալգորիթմները,  սակայն ունեն ավելի 
փոքր ճշտություն։
 Այսպիսի ալգորիթմների բարդությունը տատանվում է գծայինից  մինչև  քառակուսայինի՝  կախված  AST  ծառի  գագաթների  թվից  կամ 
ծրագրի  կախվածությունների  գրաֆի  գագաթներից։
  Այս  մոտեցման  վրա 
հիմնված մեթոդները գտնում են բոլոր տիպի կլոններ։
5. Սեմանտիկական մոտեցում։
 Այս մոտեցման հիմքում ընկած է ծրագրի 
կախվածությունների  գրաֆը՝  PDG  (program  dependence  graph)։
  Այս  մոտեցման  վրա  հիմնված  ալգորիթմը  որոնում  է  իզոմորֆ  ենթագրաֆներ  [10,  11]։
Այսպիսի ալգորիթմների բարդությունը կարող է էքսպոնենցիալ լինել։
 Այսպիսի 
մեթոդների ճշտությունը մեծ է մյուս մոտեցումների համեմատությամբ, սակայն 
արագությունը  զգալի  զիջում  է։
  Այս  մոտեցման  վրա  հիմնված  մեթոդները 
գտնում են բոլոր տիպի կլոններ։
Մոտեցումների  համեմատում։
  Լեքսիկական  և  տեքստային  մոտեցումները բոլոր տիպի կլոնները չեն գտնում։
 Մյուս մեթոդները բոլոր երեք տիպի կլոնները  գտնում  են,  բայց  մետրիկաների  վրա  հիմնված  մոտեցումների  ճշգրտությունը ցածր է։
 Ընդհանուր առմամբ PDG-ի վրա հիմնված ալգորիթմներն ավելի ճշգրիտ են քան AST-ի վրա հիմնված մեթոդները։
 Քանի որ AST-ն պարունակում է միայն ծրագրի կառուցվածքի մասին ինֆորմացիա։
 Իսկ PDG-ն ունի ինֆորմացիա  ինչպես  կառուցվածքի,  այնպես  էլ  սեմանտիկայի  մասին։
  Հետևաբար  բարձր  ճշտություն ապահովելու համար պետք  է  օգտագործել սեմանտիկական մոտեցումը։
Java-ի դաս ֆայլ։
 Java-ի դաս ֆայլը՝ դա Java բայթկոդ պարունակող ֆայլ 
է  (.class  ընդլայնումով),  որը  կարող  է  կատարվել  Java-ի  վիրտուալ  մեքենայի 
վրա։
  Java  բայթկոդը  Java-ի  վիրտուալ  մեքենայի  ինստրուկցիաների  բազմություն  է։
  Java-ի  դաս  ֆայլը  ստեղծվում  է  Java  ծրագրավորման  լեզվի  նախնական ֆայլերից (.java ֆայլ)՝ Java-ի կոմպիլյատորի միջոցով։
 Եթե մի նախնական 
ֆայլն ունի մեկից ավել դասեր, ապա յուրաքանչյուր դասի կոմպիլյացիայի արդյունքը պահվում է տարբեր դասի ֆայլերում։
Java-ի դաս ֆայլը բաղկացած է 10 հիմնական մասից․ 
1.  Մոգական համար՝ 0xCAFEBABE 
2.  Դաս  ֆայլի  ֆորմատի  տարբերակ`  դաս  ֆայլի  մինոր  և  մաժոր  տարբերակները  
3.  Հաստատունների ավազան՝ դաս ֆայլի հաստատունների համար 
4.  Հասանելիության դրոշ՝ օրինակ՝ արդյո՞ք դասը աբստրակտ է, ստատիկ 
և այլն 
5.  This դաս՝ ընթացիկ դասի անունը 
6.  Super դաս` super դասի անունը 
7.  Ինտերֆեյսներ՝ դասում գտնվող ինտերֆեյսները 
8.  Դաշտեր՝ դասում գտնվող դաշտերը 
9.  Մեթոդներ՝ դասում գտնվող մեթոդները 
10.  Ատրիբուտներ՝  դասի  ատրիբուտները  (օրինակ՝  նախնական  ֆայլի 
անունը ․․․) 
Ծրագրի  կախվածության  գրաֆի  գեներացիա։
  Ծրագրի  կախվածությունների  գրաֆը՝  PDG,  ուղղորդված  գրաֆ  է,  որն  այս  դեպքում  ստացվում  է 
Java-ով գրված ծրագրի կոմպիլյացիայի արդյունքում ստացվող բայթկոդից (Նկ․ 
2)։
  PDG-ի  գագաթներին  համապատասխանում  են  բայթկոդի  ինստրուկցիաներ, իսկ կողերին՝ այդ ինստրուկցիաների միջև տվյալների կամ ղեկավարման 
հոսքի  կախվածություններ։
  Գոյություն  ունեն  3  հիմնական  տիպի  տվյալների 
կախվածություններ՝ ճիշտ (true), անտի (anti) և արտաքին (output)։
 Աշխատանքում օգտագործվել են ղեկավարման և տվյալների հոսքից՝ ճիշտ տիպի տվյալների կախվածությունները։
 Ստացված PDG-ն գրվում է ֆայլում։
Նկ․ 2։
 PDG-ի գեներացիա .class ֆայլի հիման վրա 
PDG-ից ծառի ստացում։
 Որպեսզի գրաֆը ծառի ձևափոխելուց PDG-ում 
պարունակվող  ինֆորմացիան  հնարավորինս  ճիշտ  պահպանվի  (այսինքն 
երկու գրաֆների ինչ-որ ենթագրաֆներ, որոնք իզոմորֆ են, ծառի ձևափոխվելուց մնան իզոմորֆ), ավելացվում են նոր գագաթներ և կողեր։
Ծառ ստանալու ալգորիթմի նկարագրություն․  
1.  Մուտք․ PDG գրաֆ 
2.  Գագաթները դասավորվում են ըստ իրենց ID-ների աճման կարգի 
3.  Եթե  ∃v  ∈PDG  գագաթ,  որի  մտնող  կողերի  թիվը  1-ից  մեծ  է,  ապա 
անցում է կատարվում 4 քայլին, հակառակ դեպքում՝ 5 քայլին 
4.  Նոր գագաթ է ստեղծվում, որն ունի նույն տվյալները ինչ v-ն և ավելացվում  v-ի  ծնող  u  գագաթին  որպես  որդի,  v  և  u  գագաթները  միացնող 
կողը  հեռացվում  է։
  Այս  քայլը  կատարվում  է  v-ի  բոլոր  ծնողների  համար, բացի վերջինից և անցում է կատարվում 3 քայլին 
5.  Կատարվում է ցիկլերի հեռացում 
6.  Ելք․ ծառ 
Ցիկլերի հեռացում․ 
1.  Մուտք․ PDG գրաֆ 
2.  Բոլոր գագաթների mark-երին վերագրվում է 0։
3.  Քանի  դեռ  կա  չդիտարկված  գագաթ,  դիտարկվում  է  հերթական  գագաթը։
 Հակառակ դեպքում կատարվում է անցնում 8 քայլին 
4.  Եթե գագաթի mark-ը 0 է, տեղադրվում է հերթի մեջ 
5.  Եթե  հերթը  դատարկ  չէ,  հերթից  հանվում  է  currNode  գագաթը  և  իր 
mark-ին վերագրվում 1։
 Հ․դ․ կատարվում է անցում 3 քայլին 
6.  Եթե  currNode-ից  դուրս  եկող  v  գագաթի  mark-ը  1  է,  այսինքն  արդեն 
դիտարկվել  է  նախորդ  քայլերում,  ապա  currNode  և  v  գագաթները 
միացնող կողը հեռացվում է 
7.  Հակառակ դեպքում, եթե v գագաթի mark-ը 0 է, այն ավելացվում է հերթում և անցում կատարվում 5 քայլին 
8.  Ելք․ ծառ 
Կլոնների որոնման ալգորիթմի նկարագրություն։
 Այն հիմնված է ստացված ծառի գագաթների համեմատման վրա։
 Ալգորիթմը համեմատում է երկու 
ծառեր՝ P1 և P2, որոնցից ստացվում են ենթածառեր, որոնք հանդիսանում են 
կլոններ։
 Ալգորիթմն աշխատում է հետևյալ քայլերի հաջորդականությամբ․ 
Դիտարկվում է PDT1 և PDT2-ից կազմված անտառը։
 Ալգորիթմի ընթացքում անտառի յուրաքանչյուր գագաթի վերագրվում է ամբողջ թիվ այնպես, որ 
ցանկացած  երկու  գագաթի  վերագրված  է  միևնույն  թիվը  այն  և  միայն  այն 
դեպքում, երբ նրանցով առաջացած ենթածառերը իրար իզոմորֆ են։
Իզոմորֆիզմի ալգորիթմ․ 
1.  Մուտք․ PDT1, PDT2  
2.  Մի  ծրագրի  կախվածության  ծառի  գագաթների  mark-ը  0  ենք  նշում, 
մյուսինը՝ 1։
 Բոլոր գագաթների համար կատարում որոշակի հաշվարկներ։
3.  Քանի դեռ դիտարկվող գագաթների հերթը դատարկ չի 
3.1. CurrNode-ին վերագրում ենք դիմացի գագաթը 
3.2. Եթե currNode-ը հաջորդ մակարդակից է և տրված մակարդակ ենք 
հասել,  ապա  նախորդ  մակարդակի  իզոմորֆ  գագաթները  ավելացնում ենք համապատասխան f և s բազմությունների մեջ 
3.3. CurrNode-ի  համար  կանչում  ենք  ամբողջ  թվի  վերագրման  ֆունկցիան 
3.4. Եթե currNode-ը ծառի արմատ չէ 
3.4.1. Ծնողի  չդիտարկված  գագաթների  քանակը  1-ով  պակասեցնում ենք և մակարդակին վերագրում currNode-ի մակարդակը 1-ով ավելացրած 
3.4.2. Եթե  ծնողի  չդիտարկված  գագաթների  քանակը  0  է,  ծնողը 
ավելացնում ենք հերթի մեջ 
4.  Ելք․  
Որոշակի հաշվարկներ․ 
1.  Ամեն մի գագաթի համար պահում ենք որդիների քանակը 
2.  Եթե որդի չունի, ապա մակարդակին վերագրում ենք 0, գագաթը ավելացնում հերթի մեջ  
Ամբողջ թվի վերագրում․ 
1.  Վեկտորի  մեջ  պահում  ենք  currNode-ի  բոլոր  որդիներին  վերագրված 
ամբողջ թվերը։
 Սորտավորում, ավելացնում դիմացից currNode-ի Id-ն 
2.  Եթե  setMap-ում  արդեն  կա  այդպիսի  վեկտոր,  ապա  անցնում  ենք  2.1 
քայլին, հ․դ․՝ անցնում ենք 3 քայլին 
2.1. Այդ  վեկտորին  համապատասխան  ամբողջ  թիվը  վերագրում  ենք 
գագաթին 
2.2. Տրված թիվը ունեցող գագաթների վեկտորի մեջ ավելացնում ենք 
այդ գագաթը, անցնում 7 քայլին 
3.  SetMap-ում ավելացնում ենք վեկտորը 
4.  Նրան և currNode գագաթին համապատասխանեցնում count-ը 
5.  Count ունեցողների մեջ ավելացնում այդ գագաթը 
6.  Count-ը մեծացնում 1-ով  
7.  Ելք․ 
Ցանկալի է տեսնել ալգորիթմի աշխատանքի որոշակի հետազոտություն, 
արագագործության և որակի գնահատականներ և համեմատություններ 
Գրականություն 
tools։
  a  qualitative  approach”,  Science  of  Computer 
[5]   T.Kamiya,  S.Kusumoto,  K.Inoue,  “CCFinder։
  A  multilinguistic  token-based  code  clone 
[8].   L.Jiang,  G.Misherghi,  Z.Su,  S.Glondu,  “DECKARD։
  Scalable  and  accurate  tree-based 
Հարությունյան Մարիամ 
ԿՈԴԻ ԿԼՈՆՆԵՐԻ ՈՐՈՆՈՒՄ JAVA ԾՐԱԳՐԱՎՈՐՄԱՆ ԼԵԶՎԻ ՀԱՄԱՐ՝ ՀԻՄՆՎԱԾ 
ԾՐԱԳՐԻ ՍԵՄԱՆՏԻԿ ՀԵՏԱԶՈՏՈՒԹՅԱՆ ՎՐԱ 
Բանալի բառեր՝ Կոդի կլոն, PDG, նախնական կոդ, Java, բայթկոդ, սեմանտիկ անալիզ 
Ամփոփում 
։

Ներկայումս լայն տարածում են ստացել ոչ տիպականացված սկրիպտային լեզուներով գրված ծրագրերը։
 Ծրագրավորման այդտեսակ լեզուներից լայնտարածում  ունի  JavaScript  ծրագրավորման  լեզուն։
  Համակարգիչների  և  ներդրված  համակարգերի  արդյունավետության  բարձրացման  հետ  մեկտեղJavaScript լեզվի  գործածումը հնարավոր դարձավ ոչ միայն վեբ կայքերում օգտագործվող փոքր ծավալով սկրիպտային ծրագրերում, այլ նաև ծավալուն վեբծրագրերում։
  Ավելին, որոշ  օպերացիոն համակարգեր  JavaScript  լեզուն  օգտագործում են որպես հիմնական ծրագրավորման լեզու։
 Այդպիսի համակարգերիօրինակ են Tizen[1] և FirefoxOS օպերացիոն համակարգերը։
 Որպես հետևանք`առաջանում  է  սկրիպտային  ծրագրերի  արդյունավետության  բարձրացմանպահանջարկ։
Այս  աշխատանքում  դիտարկվում  է  JavaScript  լեզվի  JavaScriptCore  (JSC)JIT  կոմպիլյատորը,    որը    վեբ  կայքերի  արտացոլման  համար  նախատեսվածWebKit  գրադարանի մի մասն է։
  Աշխատանքի նպատակն է JavaScriptCore JITկոմպիլյատորում  օպտիմալացումների  մշակումը  և  իրականացումը,  որոնքկհանգեցնեն ավելի որակյալ կոդի գեներացմանը, ինչն էլ իր հերթին կհանգեցնիJavaScript լեզվով գրված ծրագրերի արտադրողականության բարձրացմանը։
  JavaScriptCore կոմպիլյատորի կառուցվածքը[2]JavaScriptCore  կոմպիլյատորի  աշխատանքի  սկզբում  կատարվում  էլեկսիկական  և  սինտակսիկական  անալիզ։
  Սկզբնական  կոդի  հիման  վրակառուցվում  է  աբստրակտ  սինտակս  ծառ,  որի  հիման  վրա  այնուհետևկառուցվում է միջանկյալ ներկայացումը (բայթկոդ)։
JavaScriptCore կոմպիլյատորի  աշխատանքը ներկայացված է նկար 1-ում։
                                                  Նկար 1Կախված կոդի կատարման ինտենսիվությունից՝ սկզբնական կոդը թարգմանվում է մեքենայական կոդի օպտիմալացման 4 փուլերով։
Առաջին փուլում կատարվում է ծրագրի ուղղակի ինտերպրետացում։
  Այսփուլի  ընթացքում  տվյալներ  են  հավաքվում  փոփոխականների  տիպերի  ևօբյեկտների  դաշտերի  արժեքների  վերաբերյալ։
  Որպեսզի  ֆունկցիայի  թարգմանությունն անցնի երկրորդ փուլ (Baseline JIT), անհրաժեշտ է, որ ֆունկցիանհավաքի 100 «կատարման միավոր», ընդ որում ֆունկցիայի ամեն կանչն ավելացնում է 15 միավոր, իսկ ցիկլի ամեն քայլ՝ 1 միավոր։
Թարգմանության  երկրորդ  փուլում  կատարվում  է  ֆունկցիայի  դինամիկկոմպիլյացիա մեքենայական կոդի։
 Ստացված մեքենայական կոդում ամեն գործողության  համար  ներառված  են  կատարման  բոլոր  հնարավոր  տարբերակները։
  Օրինակ՝  գումարման  գործողության  արգումենտները  կարող  են  լինելթվեր կամ տառեր։
 Երկրորդ դեպքում գործողությունը պետք է կատարվի ինչպեստողերի  կոնկոտենացիա։
  Այսպիսով՝  ստացված  կոդը  կարող  է  պարունակելբազմաթիվ ճյուղավորումներ բոլոր նմանատիպ դեպքերը մշակելու համար։
Տիպերի և օբյեկտների մասին տվյալները, որոնք հավաքվում են առաջիներկու փուլերում, անհրաժեշտ են թարգմանության երրորդ փուլում սպեկուլյատիվ թարգմանության կազմակերպման համար։
Թարգմանության  երրորդ  փուլը  (DFG  JIT)  կատարվում  է  այն  ֆունկցիաների  համար,  որոնք հավաքել  են  ավելի  քան 1000  «կատարման  միավոր»։
  Այսփուլում կատարվում են բազմատեսակ օպտիմալացումներ, որոնք հիմնված ենտիպերի մասին տվյալների վրա։
 Բայթկոդ միջանկյալ ներկայացումից կառուցվում է տվյալների հոսքի գրաֆ (Data Flow Graph)[3], որում գործողություններըներկայացված են SSA[3] տեսքով։
DFG  JIT  կոմպիլյատորը  տիպերի  մասին  ստացված  ինֆորմացիան  տարածում  է  տվյալների  գրաֆով  և  կոդում  ավելացնում  է  տիպերի  անհրաժեշտստուգումներ։
Եթե  տիպի  ստուգման  արդյունքը  բացասական  է,  ապա  կատարվում  էանցում դեպի կատարման երկրորդ փուլ (OSR exit), որտեղ մեքենայական կոդում ներառված են տիպերի մշակման բոլոր դեպքերը։
 Այսպիսով՝ Baseline JIT ևDFG JIT փուլերում գեներացված մեքենայական կոդերը կարող են փոխարինելմիմյանց։
  Երբ  ֆունկցիան  հավաքում  է  բավարար  «կատարման  միավոր»,  կատարվում է անցում դեպի DFG JIT (OSR entry), իսկ երբ տեղի է ունենում փոփոխականի  տիպի  դինամիկ  փոփոխություն,  կատարվում  է  հակառակ  անցում(OSR exit)։
 Թարգմանության չորրորդ փուլը կոչվում է LLVM JIT և կատարվում էայն ֆունկցիաների համար, որոնք հավաքել են ավելի քան 10000 «կատարմանմիավոր»։
  Այստեղ  միջանկյալ  կոդի  փոխարեն  հանդես  է  գալիս  LLVM[4]  կոմպիլյատորի  բիթկոդը,  և  կատարվում  են  ավելի մեծ  թվով    օպտիմալացումներ,այդ  թվում  ՝  LLVM  կոմպիլյատորում  իրականացված  օպտիմալացումների  մեծմասը։
JavaScriptCore  դինամիկ  կոմպիլյատորի  ճարտարապետության  ուսումնասիրությունների արդյունքում պարզվեց, որ DFG JIT կոմպիլյատորում ֆիզիկական  ռեգիստրների  բաշխումը  կատարվում  է  լոկալ  եղանակով,  բազայինբլոկների  սահմաններում,  ինչը  հանգեցնում  է  նրան,  որ  ամեն  բազային  բլոկիելքում բոլոր լոկալ փոփոխականներն արտագրվում են հիշողության մեջ և հաջորդ  բազային  բլոկի  մուտքում  կրկին  բեռնվում  են  հիշողությունից։
  Հիշողությանն ուղղված ավելորդ դիմումներից ազատվելու համար մշակվել և իրականացվել է ռեգիստրների գլոբալ բաշխման ալգորիթմ JavaScriptCore JIT կոմպիլյատորում։
  Որպես հիմք  ընտրվել  է  գծային  սկանավորման  (Linear  scan)  ալգորիթմը[5]։
  Այս ալգորիթմն իրականացված է SSA միջանկյալ ներկայացման համար,  որը  նաև  հանդիսանում  է  DFG  JIT  կոմպիլյատորի  միջանկյալ  ներկայացումը։
 Ալգորիթմի իրականացման ընթացքում հաշվի են առնվել JavaScriptCoreկոմպիլյատորի հետևյալ առանձնահատկությունները.1.  Փոփոխականների  տիպերը  որոշվում  են  դինամիկ,  և  տիպերի  մասինինֆորմացիան պետք է հավաքել մինչև ռեգիստրների բաշխումը։
2.  32  բիթանոց  ճարտարապետությունների  համար  փոփոխականի  տիպը  ևարժեքը պահվում են տարբեր ռեգիստրներում։
3.  Որոշ  հրամաններ  թարգմանելու  համար  անհրաժեշտ  են  ժամանակավորռեգիստրներ։
JavaScriptCore դինամիկ կոմպիլյատորում ռեգիստրների լոկալ բաշխումըկատարվում էր կոդի գեներացիայի ընթացքում։
 Այս փուլում հասանելի են հրամանները  թարգմանելու  համար  ռեգիստրների  անհրաժեշտ  քանակի  և  փոփոխականների տիպերի վերաբերյալ պահանջվող բոլոր տվյալները։
  Ռեգիստրների  գլոբալ  բաշխման  ալգորիթմն  իր  աշխատանքն  սկսում  է  մինչև  կոդիգեներացիայի  փուլը,  որտեղ  այդ  տվյալները  հասանելի  չեն։
    Խնդիրը  լուծելուհամար կոմպիլյատորում ավելացվել է նոր փուլ, որն աշխատում է անմիջապեսռեգիստրների  բաշխման  փուլից  առաջ,  և  հավաքում  է  անհրաժեշտ  տվյալներփոփոխականների տիպերի և ռեգիստրների պահանջվող քանակի վերաբերյալ։
Ռեգիստրների  գլոբալ  բաշխումն  իրականացնելուց  հետո  հնարավոր  դարձավհեռացնել  բազային  բլոկների  մուտքերում  և  ելքերում  հիշողությանն  ուղղվածավելորդ դիմումները, բացառությամբ այն դեպքերի, երբ բազային բլոկը գտնվումէ  ցիկլի  մարմնի  մեջ։
  Ծրագրի  կատարումը  կարող  է  անցնել  baseline  JITկոմպիլյատորից դեպի DFG JIT կոմպիլյատոր ցիկլի առաջին հրամանի կատարման  ժամանակ  (OSR  Entry)[2]։
  Այդ  դեպքում  հարկավոր  է  բեռնել  բոլորանհրաժեշտ  լոկալ  փոփոխականների  արժեքները  ֆիզիկական  ռեգիստրներիմեջ։
  Խնդիրը  լուծելու  համար  միջանկյալ  ներկայացման  մեջ  ավելացվել  է  նորբազային բլոկ, որտեղ տեղադրվել են հրամաններ լոկալ փոփոխականների արժեքները ֆիզիկական ռեգիստրների մեջ բեռնելու համար։
  Այնուհետև DFG JITկոմպիլյատորի մուտքի հասցեն փոխվել է այնպես, որ այն մատնանշի նոր կառուցված բազային բլոկի մուտքի հասցեն, ինչպես պատկերված է նկար 2-ում։
Նկար 2Ծրագրում օգտագործված փոփոխականների քանակը կարող է գերազանցել  առկա  ֆիզիկական  ռեգիստրների  քանակը։
  Այդ  դեպքում  որոշ  փոփոխականներ հարկավոր է պահել հիշողության մեջ։
  Հիշողության դիմումները նվազագույնին  հասցնելու  համար  հարկավոր  է  հաճախ  օգտագործվող  փոփոխակաների  արժեքները  հնարավորության  դեպքում  պահել  ֆիզիկական  ռեգիստրներում։
  Այդ  նպատակով  ծրագրի  բոլոր  փոփոխականներին  համապատասխանեցվում է  «փոփոխականի  քաշ»  մեծությունը,  որը ուղիղ համեմատական է ծրագրի մեջ տվյալ փոփոխականի օգտագործման քանակին և այն ցիկլիխորությանը, որի մարմնում գտնվում է տվյալ փոփոխականը։
Այնուհետև ավելի փոքր քաշ ունեցող փոփոխականները համապատասխանաբար պահվում են հիշողության մեջ, իսկ մեծ քաշ ունեցողները՝ ֆիզիկական ռեգիստրներում։
JavaScriptCore  կոմպիլյատորի  ուսումնասիրության  արդյունքում  պարզվեց, որ գոյություն ունեն հրամաններ, որոնք իրականացված չեն օպտիմալացման երրորդ (DFG JIT) մակարդակում, ինչի պատճառով առաջանում են դեպքեր,երբ շատ անգամ կատարված ֆունկցիան, միևնույնն է, չի թարգմանվում DFG JITկոմպիլյատորի միջոցով։
 Այդպիսի հրամանի օրինակ է փոփոխականների տիպերի  որոշման  typeof  հրամանը։
  Այս  հրամանը  պարունակող  ֆունկցիաներըկատարվում էին  միայն  օպտիմալացման  առաջին  (LLINT)  և երկրորդ  մակարդակներում  (baseline  JIT)։
    Այդ  տեսակ  հրամանի  մեկ  այլ  օրինակ  են  ցիկլերը,որոնք նախատեսված են օբյեկտի անդամ տվյալների թվարկման համար (for-inցիկլեր)։
 DFG JIT մակարդակում իրականացվել է թվարկված երկու հրամաններիթարգմանությունը, ինչը ավելացրել է օպտիմալացման երրորդ մակարդակումթարգմանվող ֆունկցիաների քանակը։
Ուսումնասիրությունները ցույց տվեցին նաև, որ որոշ բարդ հրամաններիթարգմանութունը իրականցված է C – լեզվի ֆունկցիաների կանչերի միջոցով,ինչը պահանջում է բավական շատ ժամանակ ստեկի, ֆունկցիայի արգումենտների պատրաստման և ֆունկցիայի կանչի համար։
 Գեներացվող մեքենայականկոդի որակի բարելավման նպատակով որոշ այդպիսի հրամանների մեքենայական  կոդում  ֆունկցիայի  կանչը  փոխարինվել  է  հրամանի  ուղղակի  ասեմբլերային կոդով։
Վերոնշյալ օպտիմալացումը կատարվել է JavaScript լեզվի հետևյալ ֆունկցիաների համար։
 Math.power, Math.floօr, Math.power, String.fromCharCode։
Տվյալ աշխատանքի սահմաններում JavaScriptCore JIT կոմպիլյատորի համար մշակվել և իրականացվել են մեքենայական կոդի օպտիմալացման մի քանիեղանակներ, ինչպես նաև իրականացվել է ռեգիստրների գլոբալ բաշխման ալգորիթմը։
Այս ամենը հանգեցրել է գեներացված կոդի որակի զգալի բարելավմանը։
 Նոր հրամանների թարգմանության իրականացումը SunSpider [6] թեսթայինհավաքածուի որոշ թեսթերի արտադրողականությունը ավելացրել է 15% -ով։
Ռեգիստրների գլոբալ բաշխումը որոշ թեսթերի արտադրողականությունըբարելավել է ավելի քան 20% -ով։
